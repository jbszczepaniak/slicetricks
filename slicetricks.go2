package main

import (
	"fmt"
	"sort"
)

func main() {
	fmt.Println(Copy([]int{1,2,3}))
	fmt.Println(Cut([]int{1,2,3}, 0, 2))
	fmt.Println(Delete([]int{1,2,3}, 0))
	fmt.Println(Filter([]int{1,2,3,4,5}, func(x int) bool {return x > 2 }))
	fmt.Println(Deduplicate([]string{"a", "b", "c", "d", "e", "f", "a", "f"}))
} 

// Copy copies a slice.
// https://github.com/golang/go/wiki/SliceTricks#copy
func Copy(type T)(a []T) []T {
	b := make([]T, len(a))
	copy(b, a)
	return b
}

// Cut cuts elements.
// https://github.com/golang/go/wiki/SliceTricks#cut
func Cut(type T)(a []T, i, j int) []T {
	var zero T
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = zero
	}
	a = a[:len(a)-j+i]
	return a
}

// Delete deletes element at index.
// https://github.com/golang/go/wiki/SliceTricks#delete
func Delete(type T)(a []T, i int) []T {
	var zero T
	copy(a[i:], a[i+1:])
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	return a
}

// Filter fitlers slice based on the predicate.
// https://github.com/golang/go/wiki/SliceTricks#filtering-without-allocating
func Filter(type T)(a []T, f func(t T)bool) []T { 
	b := a[:0]
	for _, x := range a {
		if f(x) {
			b = append(b, x)
		}
	}
	return b
}

func Deduplicate(type T ordered) (in []T) []T{
	sortSlice(in)

	j := 0
	for i := 1; i < len(in); i++ {
		if in[j] == in[i] {
			continue
		}
		j++
		// preserve the original data
		// in[i], in[j] = in[j], in[i]
		// only set what is required
		in[j] = in[i]
	}
	return in[:j+1]
}



type ordered interface {
	type int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64,
		string
}

type orderedSlice(type elem ordered) []elem

func (s orderedSlice(elem)) Len() int           { return len(s) }
func (s orderedSlice(elem)) Less(i, j int) bool { return s[i] < s[j] }
func (s orderedSlice(elem)) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

func sortSlice(type elem ordered)(s []elem) {
	sort.Sort(orderedSlice(elem)(s))
}